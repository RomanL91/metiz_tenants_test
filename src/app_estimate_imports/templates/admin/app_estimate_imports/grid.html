{% extends "admin/base_site.html" %}
{% load static %}
{% load grid_extras %}

{% block extrastyle %}
<style>
  .grid-toolbar { margin: 0 0 12px; display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
  table.grid { width:100%; border-collapse: collapse; font-size:13px; }
  table.grid th, table.grid td { border:1px solid #e0e0e0; padding:4px 6px; vertical-align: top; }
  table.grid thead th { position: sticky; top: 0; background:#f8f8f8; z-index: 2; }
  .role-select { width: 220px; }
  .head-role { font-size: 11px; color:#666; }
  .head-caption { font-size: 11px; color:#333; margin-top:4px; max-width:280px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

  /* Видимость */
  .hidden-col { display:none; }
  .hidden-row { display:none; }

  /* Липкая колонка управления (чекбокс + иерархия + бейджи) */
  .control-col { width: 48px; position: sticky; left: 0; background: #f8f8f8; z-index: 4; }
  .control-cell { position: sticky; left: 0; background: #fff; z-index: 3; padding: 0 4px !important; overflow: visible; }
  .ctrl-wrap { position: relative; min-height: 22px; padding-top: 2px; }
  .ctrl-wrap .cb { position: relative; z-index: 2; }

  /* Рисуем «рёбра» иерархии в той же ячейке */
  .hier { position: absolute; inset: 0 0 0 0; z-index: 1; pointer-events: none; }
  .hier .lvl {
    position: absolute;
    top: 0;
    bottom: 0;
    width: 3px;
    background: var(--lvl-color, #9e9e9e);
    border-radius: 1px;
    opacity: .95;
  }
  .hier .elbow {
    position: absolute;
    height: 10px; width: 10px;
    border-left: 3px solid var(--elbow-color, #9e9e9e);
    border-bottom: 3px solid var(--elbow-color, #9e9e9e);
    border-bottom-left-radius: 2px;
  }

  /* Подсветка кандидатов (NAME_OF_WORK + UNIT (+QTY)) */
  .tc-row td { background: rgba(121, 174, 200, 0.18) !important; }

  /* Неучтённые UNIT */
  td.unit-bad { background: rgba(220, 20, 60, 0.14) !important; }

  /* Группы: бейдж в ячейке управления, мягкая заливка строк */
  .group-badge { font-size:11px; padding:2px 6px; border-radius:10px; display:inline-block; margin: 2px 0 0 0; cursor: pointer; white-space:nowrap; position: relative; z-index: 3; max-width: 280px; }
  .group-badge:hover { filter: brightness(0.95); }
  tr[data-group~="1"] td { background-image: linear-gradient(0deg, rgba(0,0,0,0.02), rgba(0,0,0,0.02)); }
</style>
{% endblock %}

{% block content %}
<div class="module">
  <h2>{{ title }}</h2>

  <div class="grid-toolbar">
    <a class="button" href="../change/">Назад</a>

    <label>Лист:&nbsp;
      <select id="sheet">
        {% for name in sheet_names %}
          <option value="{{ forloop.counter0 }}" {% if forloop.counter0 == sheet_index %}selected{% endif %}>{{ name }}</option>
        {% endfor %}
      </select>
    </label>

    <label style="display:flex;gap:6px;align-items:center">
      <input id="toggle-all" type="checkbox" {% if show_all %}checked{% endif %}>
      Показать все строки
    </label>

    <a class="button" id="btn-save">Сохранить схему</a>
    <a class="button" id="btn-extract">Сформировать разметку из таблицы</a>

    <a class="button" id="btn-hide-rows">Скрыть выбранные строки</a>
    <a class="button" id="btn-hide-cols">Скрыть отмеченные колонки</a>
    <a class="button" id="btn-show-all">Показать всё</a>

    <!-- Группы -->
    <a class="button" id="btn-group-create">Создать группу из выделенных</a>
    <a class="button" id="btn-group-tree">Дерево групп</a>

    <span style="margin-left:auto;display:flex;gap:12px;align-items:center;">
      <label style="display:flex;gap:6px;align-items:center">
        Юниты:&nbsp;
        <input id="unit-allow" type="text" value="{{ unit_allow_raw }}" style="width:180px"
               title="Список допустимых единиц через запятую">
      </label>
      <label style="display:flex;gap:6px;align-items:center">
        <input id="require-qty" type="checkbox" {% if require_qty %}checked{% endif %}>
        Требовать КОЛ-ВО &gt; 0
      </label>
    </span>
  </div>

  <div style="margin:-8px 0 10px 0;color:#666;">
    Показано строк: <strong>{{ rows|length }}</strong> из <strong>{{ total_rows }}</strong>.
    &nbsp; Кандидатов: <strong id="tc-counter">0</strong>.
    &nbsp; Неучтённых UNIT: <strong id="unit-bad-counter">0</strong>
    <span id="unit-bad-list" style="margin-left:8px;"></span>
  </div>

  <div style="overflow:auto; max-height: calc(100vh - 260px); border:1px solid #e0e0e0;">
    <table class="grid" id="grid">
      <thead>
        <tr>
          <th class="control-col"></th>
          {% for col in cols %}
            <th data-col="{{ col }}">
              <div><input type="checkbox" class="col-check" data-col="{{ col }}" title="Отметить колонку для скрытия"></div>

              <select class="role-select" data-col="{{ col }}">
                {% for r in role_defs %}
                  <option value="{{ r.id }}"
                          data-color="{{ r.color }}"
                          data-required="{{ r.required|yesno:'1,0' }}"
                          {% if col_roles|index:col == r.id %}selected{% endif %}>
                    {{ r.title }}
                  </option>
                {% endfor %}
              </select>

              <div class="head-role">Колонка {{ col|excel_col }}</div>
              {% if col_headers|index:col %}
                <div class="head-caption">{{ col_headers|index:col }}</div>
              {% endif %}
            </th>
          {% endfor %}
        </tr>
      </thead>

      <tbody>
        {% for r in rows %}
        <tr data-row="{{ r.row_index }}" class="row">
          <td class="control-cell">
            <div class="ctrl-wrap">
              <input type="checkbox" class="row-check cb" title="Выделить строку (Shift — диапазон)">
              <div class="hier"></div>
              <!-- сюда же добавляются бейджи групп для строки-старта -->
            </div>
          </td>
          {% for col in cols %}
            {% with val=r.cells|index:col %}
              <td data-col="{{ col }}">{{ val }}</td>
            {% endwith %}
          {% endfor %}
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </div>

  <p style="margin-top:8px;color:#666;">
    Обязательные роли: <strong>НАИМЕНОВАНИЕ РАБОТ/ТК</strong>, <strong>ЕД. ИЗМ.</strong>, <strong>КОЛ-ВО</strong>.<br>
    Для групп: выделите строки (можно с Shift) → «Создать группу из выделенных». Бейдж кликабелен — удаляет группу (с её потомками) после подтверждения.
  </p>
</div>
{% endblock %}

{% block footer %}
<script>
document.addEventListener('DOMContentLoaded', function () {
  // helpers
  function getCookie(name){const m=document.cookie.match('(^|;)\\s*'+name+'\\s*=\\s*([^;]+)'); return m?m.pop():'';}
  const CSRF = getCookie('csrftoken');

  function navigateWith(params){
    const base = window.location.pathname;
    const p = new URLSearchParams(window.location.search);
    if (params.sheet != null) p.set('sheet', params.sheet);
    if (params.all != null)   p.set('all', params.all ? '1' : '0');
    const qs = p.toString();
    window.location.assign(qs ? (base + '?' + qs) : base);
  }

  // endpoints
  const SAVE_URL      = window.location.pathname.replace(/\/grid\/?$/, "/api/save-schema/");
  const EXTRACT_URL   = window.location.pathname.replace(/\/grid\/?$/, "/api/extract-from-grid/");
  const GROUPS_LIST   = window.location.pathname.replace(/\/grid\/?$/, "/api/groups/list/");
  const GROUPS_CREATE = window.location.pathname.replace(/\/grid\/?$/, "/api/groups/create/");
  const GROUPS_DELETE = window.location.pathname.replace(/\/grid\/?$/, "/api/groups/delete/");
  const AUTO_GROUPS_URL = window.location.pathname.replace(/\/grid\/?$/, "/api/auto-groups-from-colors/");

  // sheet + show_all controls
  document.getElementById('sheet')?.addEventListener('change', (e)=> navigateWith({sheet: e.target.value}));
  document.getElementById('toggle-all')?.addEventListener('change', (e)=> navigateWith({all: e.target.checked}));

  // roles helpers
  function collectRoles(){
    const roles = [];
    document.querySelectorAll('.role-select').forEach(sel=>{
      roles[parseInt(sel.dataset.col,10)] = sel.value;
    });
    return roles;
  }
  function getColsByRole(roleId){
    return Array.from(document.querySelectorAll('.role-select'))
      .filter(sel => sel.value === roleId)
      .map(sel => parseInt(sel.dataset.col, 10));
  }

  // Функция для автоматического создания групп по цветам
  async function autoCreateGroupsFromColors(nameColIndex, force = false) {
    const sheet = new URLSearchParams(location.search).get('sheet') || '0';
    
    try {
      const resp = await fetch(AUTO_GROUPS_URL, {
        method: 'POST',
        headers: {'Content-Type': 'application/json', 'X-CSRFToken': CSRF},
        body: JSON.stringify({
          sheet_index: parseInt(sheet, 10) || 0,
          name_of_work_col: nameColIndex,
          force: force
        })
      });
      
      const data = await resp.json();
      
      // Требуется подтверждение
      if (data.requires_confirmation) {
        const confirmed = confirm(
          data.message + '\n\n' +
          'Продолжить? Все существующие группы будут удалены и созданы заново на основе цветов.'
        );
        
        if (confirmed) {
          // Повторный вызов с force=true
          return await autoCreateGroupsFromColors(nameColIndex, true);
        } else {
          return { ok: false, cancelled: true };
        }
      }
      
      // Обработка результата
      if (data.ok) {
        let message = `Автоматически создано групп: ${data.groups_created}`;
        
        if (data.had_existing_groups) {
          message += '\n(Предыдущие группы были удалены)';
        }
        
        if (data.warnings && data.warnings.length > 0) {
          message += '\n\nПредупреждения:\n' + data.warnings.join('\n');
        }
        
        alert(message);
        
        // Перерисовываем группы
        await repaintGroups();
        
        return data;
      } else {
        alert('Ошибка создания групп: ' + (data.error || 'неизвестная ошибка'));
        return data;
      }
      
    } catch (error) {
      alert('Ошибка запроса: ' + error.message);
      return { ok: false, error: error.message };
    }
  }

  // colorize headers by selected role color
  function applyHeaderColors(){
    document.querySelectorAll('.role-select').forEach(sel=>{
      const th = sel.closest('th');
      const opt = sel.selectedOptions[0];
      const color = opt?.dataset?.color || '#ffffff';
      if (th) th.style.background = color;
    });
  }

  // Units normalization
  function normalizeUnit(u) {
    if (!u) return "";
    let s = (u || "").toLowerCase().trim();
    s = s.replaceAll('\u00B2', '2').replaceAll('\u00B3', '3').replace(/\s+/g, ' ').trim();
    const compact = s.replace(/\s|\.|\,/g, '');
    if (/^(м\^?2|м2|квм|мкв|квадратн\w*метр\w*)$/.test(compact)) return 'м2';
    if (/^(м\^?3|м3|кубм|мкуб|кубическ\w*метр\w*)$/.test(compact)) return 'м3';
    if (/^(шт|штука|штуки|штук)$/.test(compact)) return 'шт';
    if (/^(пм|погм|погонныйметр|погонных\s*метров)$/.test(compact)) return 'пм';
    if (/^(компл|комплект|комплекта|комплектов)$/.test(compact)) return 'компл';
    return compact;
  }
  function getAllowedUnitSet() {
    const raw = (document.getElementById('unit-allow')?.value || "").split(',');
    const set = new Set();
    for (const x of raw) {
      const norm = normalizeUnit(x);
      if (norm) set.add(norm);
    }
    return set;
  }
  function firstNonEmptyCellText(tr, cols) {
    for (const c of cols) {
      const td = tr.querySelector(`td[data-col="${c}"]`);
      if (!td) continue;
      const t = (td.textContent || '').trim();
      if (t) return t;
    }
    return "";
  }
  function anyNonEmpty(tr, cols) {
    return cols.some(c => {
      const td = tr.querySelector(`td[data-col="${c}"]`);
      return td && (td.textContent || '').trim() !== '';
    });
  }
  function qtyValue(tr, cols) {
    for (const c of cols) {
      const td = tr.querySelector(`td[data-col="${c}"]`);
      if (!td) continue;
      const raw = (td.textContent || '').replace(/\s/g, '').replace(',', '.');
      const num = parseFloat(raw);
      if (!isNaN(num)) return num;
    }
    return NaN;
  }

  // dynamic row hints: NAME_OF_WORK + UNIT (+ QTY)
  function applyRowHints(){
    const nameCols = getColsByRole('NAME_OF_WORK');
    const unitCols = getColsByRole('UNIT');
    const qtyCols  = getColsByRole('QTY');
    const requireQty = !!document.getElementById('require-qty')?.checked;
    const allowedUnits = getAllowedUnitSet();

    const rows = document.querySelectorAll('#grid tbody tr');
    let tcCount = 0;
    let unitBadCount = 0;
    const badUnitsSet = new Set();

    rows.forEach(tr => {
      tr.classList.remove('tc-row');
      tr.querySelectorAll('td.unit-bad').forEach(td => td.classList.remove('unit-bad'));

      // кандидаты
      const hasName = anyNonEmpty(tr, nameCols);
      const unitRaw = firstNonEmptyCellText(tr, unitCols);
      const unitNorm = normalizeUnit(unitRaw);
      const hasUnit = !!unitNorm && (allowedUnits.size === 0 || allowedUnits.has(unitNorm));

      let okQty = true;
      if (requireQty) {
        const q = qtyValue(tr, qtyCols);
        okQty = !isNaN(q) && q > 0;
      }
      if (hasName && hasUnit && okQty) {
        tr.classList.add('tc-row');
        tcCount++;
      }

      // неучтённые UNIT
      unitCols.forEach(c => {
        const td = tr.querySelector(`td[data-col="${c}"]`);
        if (!td) return;
        const raw = (td.textContent || '').trim();
        if (!raw) return;
        const norm = normalizeUnit(raw);
        if (!norm) return;
        if (allowedUnits.size > 0 && !allowedUnits.has(norm)) {
          td.classList.add('unit-bad');
          unitBadCount++;
          badUnitsSet.add(raw);
        }
      });
    });

    document.getElementById('tc-counter').textContent = String(tcCount);
    document.getElementById('unit-bad-counter').textContent = String(unitBadCount);
    const listEl = document.getElementById('unit-bad-list');
    const items = Array.from(badUnitsSet).slice(0, 20).map(x => `<code>${x}</code>`).join(', ');
    listEl.innerHTML = items ? `| Примеры: ${items}${badUnitsSet.size > 20 ? '…' : ''}` : '';
  }

  // guard: обязательные роли назначены?
  function requiredRolesPresent(){
    const need = new Set(['NAME_OF_WORK','UNIT','QTY']);
    document.querySelectorAll('.role-select').forEach(sel => {
      need.delete(sel.value);
    });
    return need.size === 0;
  }

  // init: цвет шапок + подсказки
  function refreshUI(){
    applyHeaderColors();
    applyRowHints();
  }

  // ВАЖНО: События селектов/параметров с проверкой роли NAME_OF_WORK
  document.querySelectorAll('.role-select').forEach(sel => {
    sel.addEventListener('change', async (e) => {
      const newRole = e.target.value;
      const colIndex = parseInt(e.target.dataset.col, 10);
      
      // Если назначена роль NAME_OF_WORK
      if (newRole === 'NAME_OF_WORK') {
        // Спрашиваем у пользователя
        const shouldAuto = confirm(
          'Обнаружена колонка "НАИМЕНОВАНИЕ РАБОТ/ТК".\n\n' +
          'Запустить автоматическое создание групп на основе цветовой разметки?\n' +
          '(Требуются назначенные роли UNIT и QTY для фильтрации)'
        );
        
        if (shouldAuto) {
          // ВАЖНО: Сначала сохраняем схему с текущими ролями
          const col_roles = collectRoles();
          const sheet = new URLSearchParams(location.search).get('sheet') || '0';
          
          const saveResp = await fetch(SAVE_URL, {
            method:'POST',
            headers:{'Content-Type':'application/json','X-CSRFToken':CSRF},
            body: JSON.stringify({
              col_roles,
              sheet_index: parseInt(sheet,10)||0,
              unit_allow_raw: getUnitAllowRaw(),
              require_qty: getRequireQty(),
            })
          });
          
          const saveData = await saveResp.json();
          if (!saveData.ok) {
            alert('Ошибка сохранения схемы: '+(saveData.error||'unknown'));
            return;
          }
          
          // Теперь запускаем автосоздание групп
          await autoCreateGroupsFromColors(colIndex);
        }
      }
      
      refreshUI();
    });
  });

  document.getElementById('unit-allow')?.addEventListener('input', applyRowHints);
  document.getElementById('require-qty')?.addEventListener('change', applyRowHints);

  function getUnitAllowRaw(){ return document.getElementById('unit-allow')?.value || ""; }
  function getRequireQty(){ return !!document.getElementById('require-qty')?.checked; }

  // save schema
  document.getElementById('btn-save').onclick = async ()=>{
    const col_roles = collectRoles();
    const sheet = new URLSearchParams(location.search).get('sheet') || '0';
    const resp = await fetch(SAVE_URL, {
      method:'POST',
      headers:{'Content-Type':'application/json','X-CSRFToken':CSRF},
      body: JSON.stringify({
        col_roles,
        sheet_index: parseInt(sheet,10)||0,
        unit_allow_raw: getUnitAllowRaw(),
        require_qty: getRequireQty(),
      })
    });
    const data = await resp.json();
    if (!data.ok) alert('Ошибка сохранения: '+(data.error||'unknown')); else alert('Схема сохранена');
  };

  // extract
  document.getElementById('btn-extract').onclick = async ()=>{
    if (!requiredRolesPresent()){
      alert('Назначьте обязательные роли: «НАИМЕНОВАНИЕ РАБОТ/ТК», «ЕД. ИЗМ.», «КОЛ-ВО».');
      return;
    }
    const col_roles = collectRoles();
    const sheet = new URLSearchParams(location.search).get('sheet') || '0';
    const resp = await fetch(EXTRACT_URL, {
      method:'POST',
      headers:{'Content-Type':'application/json','X-CSRFToken':CSRF},
      body: JSON.stringify({
        col_roles,
        sheet_index: parseInt(sheet,10)||0,
        unit_allow_raw: getUnitAllowRaw(),
        require_qty: getRequireQty(),
      })
    });
    const data = await resp.json();
    if (!data.ok) alert('Ошибка извлечения: '+(data.error||'unknown')); else alert('Разметка построена. Открой «Граф» или «Разметить».');
  };

  // hide/show UI
  document.getElementById('btn-hide-rows').onclick = ()=> {
    document.querySelectorAll('.row-check:checked').forEach(cb=> cb.closest('tr')?.classList.add('hidden-row'));
  };
  document.getElementById('btn-hide-cols').onclick = ()=> {
    document.querySelectorAll('.col-check:checked').forEach(cb=>{
      const col = parseInt(cb.dataset.col, 10);
      document.querySelector(`#grid thead th[data-col="${col}"]`)?.classList.add('hidden-col');
      document.querySelectorAll(`#grid tbody td[data-col="${col}"]`).forEach(td=> td.classList.add('hidden-col'));
    });
  };
  document.getElementById('btn-show-all').onclick = ()=> {
    document.querySelectorAll('.hidden-row').forEach(el=> el.classList.remove('hidden-row'));
    document.querySelectorAll('.hidden-col').forEach(el=> el.classList.remove('hidden-col'));
    document.querySelectorAll('.row-check, .col-check').forEach(cb=> cb.checked = false);
    refreshUI();
  };

  /* =========================
     ГРУППЫ / ПОД-ГРУППЫ
     ========================= */

  // Shift-range выделение строк
  let lastRowClicked = null;
  document.querySelectorAll('.row-check').forEach(cb=>{
    cb.addEventListener('click', (e)=>{
      const tr = cb.closest('tr');
      const idx = parseInt(tr?.dataset.row, 10);
      if (e.shiftKey && lastRowClicked != null) {
        const [a,b] = [lastRowClicked, idx].sort((x,y)=>x-y);
        document.querySelectorAll('#grid tbody tr').forEach(r=>{
          const ri = parseInt(r.dataset.row, 10);
          if (ri>=a && ri<=b) r.querySelector('.row-check').checked = true;
        });
      }
      lastRowClicked = idx;
    });
  });

  // Собрать выделенные строки -> склеить в диапазоны
  function selectedRanges(){
    const rows = Array.from(document.querySelectorAll('.row-check'))
      .map(cb => cb.checked ? parseInt(cb.closest('tr').dataset.row, 10) : null)
      .filter(Boolean).sort((a,b)=>a-b);
    const out = [];
    let start = null, prev = null;
    for (const r of rows){
      if (start==null){ start = prev = r; continue; }
      if (r === prev+1){ prev = r; continue; }
      out.push([start, prev]); start = prev = r;
    }
    if (start!=null) out.push([start, prev]);
    return out;
  }

  async function fetchGroups(){
    const sheet = new URLSearchParams(location.search).get('sheet') || '0';
    const resp = await fetch(`${GROUPS_LIST}?sheet_index=${sheet}`);
    const data = await resp.json();
    return data.ok ? (data.groups || []) : [];
  }

  function rangesCoveredBy(parentRanges, childRanges){
    return childRanges.every(([s2,e2]) => parentRanges.some(([s1,e1]) => s1<=s2 && e2<=e1));
  }

  async function promptCreateGroup(ranges){
    const groups = await fetchGroups();
    const byId = Object.fromEntries(groups.map(g=>[g.uid,g]));
    function depthOf(uid){
      let d=0; let cur = byId[uid];
      while (cur && cur.parent_uid){ d++; cur = byId[cur.parent_uid]; }
      return d;
    }
    groups.forEach(g=> g._depth = depthOf(g.uid));

    const candidates = groups.filter(g => rangesCoveredBy(g.rows||[], ranges));
    const name = window.prompt('Название группы:','Группа');
    if (!name) return null;
    let parent_uid = null;
    if (candidates.length){
      const s = ['(0) — без родителя'].concat(candidates.map((g,i)=>`(${i+1}) ${'  '.repeat(g._depth)}${g.name}`)).join('\n');
      const pick = window.prompt(`Выберите родителя:\n${s}\nВведите номер:`, '0');
      const n = parseInt(pick||'0',10)||0;
      if (n>0) parent_uid = candidates[n-1].uid;
    }
    const palette = ['#F0F4C3','#D1C4E9','#B2EBF2','#FFECB3','#C8E6C9','#FFE0B2','#E1BEE7','#FFCDD2'];
    const color = palette[Math.floor(Math.random()*palette.length)];
    return {name, parent_uid, color};
  }

  // Создать группу из выделенных
  document.getElementById('btn-group-create').onclick = async ()=>{
    const ranges = selectedRanges();
    if (!ranges.length){ alert('Сначала выделите строки (чекбоксы, можно с Shift).'); return; }
    const cfg = await promptCreateGroup(ranges);
    if (!cfg) return;
    const sheet = new URLSearchParams(location.search).get('sheet') || '0';
    const resp = await fetch(GROUPS_CREATE, {
      method:'POST',
      headers:{'Content-Type':'application/json','X-CSRFToken':CSRF},
      body: JSON.stringify({ sheet_index: parseInt(sheet,10)||0, name: cfg.name, rows: ranges, parent_uid: cfg.parent_uid, color: cfg.color })
    });
    const data = await resp.json();
    if (!data.ok){ alert('Ошибка создания группы: '+(data.error||'unknown')); return; }
    await repaintGroups();
    document.querySelectorAll('.row-check:checked').forEach(cb=> cb.checked=false);
  };

  // Быстрое дерево групп (alert)
  document.getElementById('btn-group-tree').onclick = async ()=>{
    const groups = await fetchGroups();
    const children = {};
    groups.forEach(g=>{
      const p = g.parent_uid || '_root';
      (children[p] ||= []).push(g);
    });
    function walk(pid, depth, acc){
      (children[pid]||[]).forEach(g=>{
        acc.push(`${'  '.repeat(depth)}- ${g.name}  [${JSON.stringify(g.rows)}]`);
        walk(g.uid, depth+1, acc);
      });
    }
    const lines = []; walk('_root', 0, lines);
    alert(lines.join('\n') || 'Пока нет групп');
  };

  // Удаление группы
  async function deleteGroup(uid){
    const sheet = new URLSearchParams(location.search).get('sheet') || '0';
    const ok = confirm('Удалить эту группу и все её вложенные под-группы?');
    if (!ok) return;
    const resp = await fetch(GROUPS_DELETE, {
      method:'POST',
      headers:{'Content-Type':'application/json','X-CSRFToken':CSRF},
      body: JSON.stringify({ sheet_index: parseInt(sheet,10)||0, uid })
    });
    const data = await resp.json();
    if (!data.ok){ alert('Ошибка удаления: '+(data.error||'unknown')); return; }
    repaintGroups();
  }

  // Рендер «рёбер» и бейджей прямо в колонке управления
  function renderHierarchyInControl(groups){
    const byId = Object.fromEntries(groups.map(g=>[g.uid,g]));
    function depthOf(uid){
      let d=0; let cur = byId[uid];
      while (cur && cur.parent_uid){ d++; cur = byId[cur.parent_uid]; }
      return d;
    }
    groups.forEach(g=> g._depth = depthOf(g.uid));

    const MAX_LEVELS = 4; // рисуем до 4 уровней в узкой колонке

    document.querySelectorAll('#grid tbody tr').forEach(tr=>{
      const rowNum = parseInt(tr.dataset.row,10);
      const ctrl = tr.querySelector('.ctrl-wrap');
      const hier = tr.querySelector('.hier');
      if (!ctrl || !hier) return;
      hier.innerHTML = '';

      // группы, покрывающие текущую строку, по глубине
      const covering = groups
        .filter(g => (g.rows||[]).some(([s,e]) => rowNum>=s && rowNum<=e))
        .sort((a,b) => a._depth - b._depth);

      // уровень -> цвет
      const levelColors = new Map();
      covering.forEach(g => {
        const lvl = Math.min(g._depth, MAX_LEVELS-1);
        if (!levelColors.has(lvl)) levelColors.set(lvl, g.color);
      });

      // вертикали
      levelColors.forEach((color, level) => {
        const l = document.createElement('div');
        l.className = 'lvl';
        l.style.left = (level*10 + 4) + 'px';     // центр 3px полосы в 10px «слоте»
        l.style.setProperty('--lvl-color', color);
        hier.appendChild(l);
      });

      // стартующие группы
      const startsHere = groups
        .filter(g => (g.rows||[]).some(([s,e]) => rowNum === s))
        .sort((a,b)=>a._depth-b._depth);

      startsHere.forEach(g=>{
        const level = Math.min(g._depth, MAX_LEVELS-1);
        const elbow = document.createElement('div');
        elbow.className = 'elbow';
        elbow.style.left = (level*10 + 4) + 'px';
        elbow.style.top  = '2px';
        elbow.style.setProperty('--elbow-color', g.color);
        hier.appendChild(elbow);
      });

      // бейджи (с отступом)
      ctrl.querySelectorAll('.group-badge').forEach(b=> b.remove());
      startsHere.forEach(g=>{
        const level = Math.min(g._depth, MAX_LEVELS-1);
        const badge = document.createElement('span');
        badge.className = 'group-badge';
        badge.dataset.uid = g.uid;
        badge.style.background = g.color;
        badge.style.marginLeft = (level*10 + 14) + 'px';  // отступ от «рёбер»
        badge.title = 'Клик — удалить группу';
        badge.textContent = g.name;
        badge.addEventListener('click', ()=> deleteGroup(g.uid));
        ctrl.appendChild(badge);
      });
    });
  }

  // Заливка строк групп (как раньше)
  function fillGroupRows(groups){
    document.querySelectorAll('#grid tbody tr').forEach(tr=>{
      tr.style.backgroundImage = ''; tr.dataset.group = '';
    });
    groups.forEach(g=>{
      (g.rows||[]).forEach(([s,e])=>{
        for (let r=s; r<=e; r++){
          const tr = document.querySelector(`#grid tbody tr[data-row="${r}"]`);
          if (!tr) continue;
          const overlay = `${g.color}22`;
          tr.style.backgroundImage = `linear-gradient(0deg, ${overlay}, ${overlay})`;
          tr.dataset.group = (tr.dataset.group ? tr.dataset.group+' ' : '') + '1';
        }
      });
    });
  }

  // Комплексный перерисовщик
  async function repaintGroups(){
    const groups = await fetchGroups();
    fillGroupRows(groups);
    renderHierarchyInControl(groups);
  }

  // первый рендер
  refreshUI();
  repaintGroups();
});
</script>
{% endblock %}